# Keeping Components Pure

- 일부 `JS` 함수는 순수합니다.
- 순수 함수는 계산만 수행하며 부수 효과가 없습니다.
- 컴포넌트를 순수 함수로만 작성하면 당황스러운 버그를 피할 수 있습니다.
- 그러나 따라야 할 몇 가지 규칙이 있습니다.

## 배우게 될 것

- 순수성의 정의와 버그를 피하는 방법
- 렌더링 단계에서, 변경 사항을 유지하며 컴포넌트를 순수하게 유지하는 방법
- 컴포넌트의 실수를 방지하기 위해 `Strict Mode`를 사용하는 방법

## 순수성: 공식으로서의 컴포넌트

- 컴퓨터 공학에서(특히 함수형 프로그래밍에서), 순수 함수의 특징은 아래와 같습니다.

1. 함수 자신의 기능에만 집중합니다.

   - 호출되기 전 존재하는 모든 값들을 변경하지 않습니다.

2. 동일 입력, 동일 출력.
   - 동일한 입력에 대해 동일한 출력만 반환합니다.

```js
function double(number) {
  return 2 * number;
}
```

- `double`은 순수 함수입니다.
- 3이 전달되면 **항상** 6을 반환합니다.

- `React`는 이 개념을 중심으로 설계되었습니다.
- 모든 컴포넌트가 **순수 함수**라고 가정합니다.
- 즉, `React` 컴포넌트는 동일한 입력이 주어지면 항상 동일한 JSX를 반환해야 합니다.

```js
function Recipe({ drinkers }) {
  return (
    <ol>
      <li>Boil {drinkers} cups of water.</li>
      <li>
        Add {drinkers} spoons of tea and {0.5 * drinkers} spoons of spice.
      </li>
      <li>Add {0.5 * drinkers} cups of milk to boil and sugar to taste.</li>
    </ol>
  );
}

export default function App() {
  return (
    <section>
      <h1>Spiced Chai Recipe</h1>
      <h2>For two</h2>
      <Recipe drinkers={2} />
      <h2>For a gathering</h2>
      <Recipe drinkers={4} />
    </section>
  );
}
```

- `Recipe`에 `drinkers={2}`를 전달하면, **항상** `2 cups of water`라는 `JSX`를 반환해야 합니다.
- 또 `drinkers={4}`를 전달하면, `4 cups of water`라는 `JSX`를 반환해야 합니다.
- 수학 공식처럼 말이죠.
  <br><br>

- 컴포넌트를 레시피로 생각할 수 있습니다.
- 레시피대로 요리한다면 항상 같은 요리를 만들 수 있을 것입니다.
- **요리**는 컴포넌트 렌더링을 위한 `JSX`입니다.

## 부수효과: 의도하지 않은 결과

- `React`의 렌더링 과정은 무결해야 합니다.
- 컴포넌트는 `JSX`만 반환해야 하며 다른 값들을 변경해선 안 됩니다.
  <br><br>

- 이 규칙을 위반하는 컴포넌트가 아래에 있습니다.

```js
let guest = 0;

function Cup() {
  // Bad: changing a preexisting variable!
  guest = guest + 1;
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup />
      <Cup />
      <Cup />
    </>
  );
}
```

- 이 컴포넌트는 함수 밖의 `guest` 변수를 업데이트합니다.
- 이는 `Cup` 컴포넌트를 호출할 때마다 다른 `JSX`가 반환되는 것을 의미합니다.
- 예측 불가능한 코드는 오류를 발생하게 합니다.
  <br><br>
- `guest`를 `props`로 전달하여 컴포넌트를 수정하였습니다.

```js
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaSet() {
  return (
    <>
      <Cup guest={1} />
      <Cup guest={2} />
      <Cup guest={3} />
    </>
  );
}
```

- 이제 컴포넌트는 순수 함수로 변경되었습니다.
- 일반적으로 컴포넌트가 특정 순서로 렌더링될 것으로 예상해서는 안 됩니다.
- 마찬가지로, 각 컴포넌트는 **자체적으로 생각** 해야 하며 다른 컴포넌트를 조정하거나 의존하려고 해서는 안 됩니다.
- 각 컴포넌트는 **자체적**으로 `JSX`를 계산해야 합니다!

## Deep Dive

- Strict Mode 사용하여 비순수 예방
  <br><br>

- `React`에는 렌더링하는 동안 읽을 수 있는 3개 입력이 있습니다.
- `props`, `state`, `context`입니다.
- 이러한 입력은 항상 **읽기 전용**으로 처리해야 합니다.
  <br><br>

- 사용자 입력에 따라 무언가를 변경하려면 변수 대신 **상태를 설정**해야 합니다.
- 컴포넌트가 렌더링되는 동안에는 변수나 객체를 변경하면 안 됩니다.
  <br><br>

- `React`는 각 컴포넌트의 기능을 두 번 호출하는 `Strict Mode`를 제공합니다.
- `Strict Mode`는 컴포넌트 기능을 두 번 호출하여 규칙을 위반하는 컴포넌트를 찾는 데 유용합니다.
  <br><br>

- 원래 예제에서는 `"Guest #1"`,` "Guest #2"` 및` "Guest #3"` 대신` "Guest #2"`,` "Guest #4"` 및` "Guest #6"`을 표시했습니다.
- 원래 기능이 비순수 함수여서 2번 호출하면 에러가 발생했습니다.
- 하지만 함수를 2번 호출하여도 순수 버전이 작동합니다.
- 순수 함수는 **계산만 하므로** 2번 호출해도 아무것도 변경되지 않습니다.
- 2번 호출해도 값이 변경되지 않습니다.
- 같은 입력, 같은 출력.
  <br><br>

- `Strict Mode`는 사용자의 앱 속도를 늦추지 않습니다.
- `Strict Mode`로 전환하려면 루트 컴포넌트를 <React.StrictMode>로 래핑하면 됩니다.
- 일부 프레임워크는 기본적으로 이 작업을 수행합니다.

## 로컬 돌연변이 - 컴포넌트의 작은 비밀

- 위의 예에서 문제는 컴포넌트가 렌더링 도중 **변수를 변경**했다는 것입니다.
- 이를 **돌연변이** 라고 합니다.
- 순수 함수는 호출 전 생성된 객체를 **변경하지 않습니다**.
  <br><br>
- 그러나 렌더링하는 동안 **방금 만든** 변수와 개체를 변경하는 것은 전혀 문제가 없습니다.
- 아래 예시는 `배열[]`을 만들고 `cups`변수에 할당한 다음 12개의 컵을 배열에 `push`합니다.

```js
function Cup({ guest }) {
  return <h2>Tea cup for guest #{guest}</h2>;
}

export default function TeaGathering() {
  let cups = [];
  for (let i = 1; i <= 12; i++) {
    cups.push(<Cup key={i} guest={i} />);
  }
  return cups;
}
```

- 만약 `cups` 변수나 `배열[]`이 `TeaGathering` 함수 밖에서 생성되었다면 부수 효과가 발생한 것입니다.
- 배열에 값을 `push`하면서 **이미 존재하는** 값을 변경했기 때문입니다.
  <br><br>
- 하지만, `TeaGathering` 내에서 렌더링 도중 생성한 것이므로 괜찮습니다.
- `TeaGathering` 밖에서는 아무런 일도 일어나지 않았기 때문입니다.
- 이를 `local mutation`이라고 칭합니다. 컴포넌트의 비밀이죠

## 부수효과가 발생할 수 있는 곳

- 함수형 프로그래밍은 순수성에 크게 의존하지만, 어느 시점에서는 무언가 바뀌어야 한다.
- 그것이 프로그래밍의 요점입니다!
- 화면 업데이트, 애니메이션 시작, 데이터 변경과 같은 이러한 **변경**을 부수효과라고 합니다.
- 그것들은 렌더링 중에 발생하는 것이 아니라 **다른 곳에서** 발생하는 것들이다.
  <br><br>

- `React`에서 부수효과는 일반적으로 **이벤트 핸들러 내부**에 속합니다.
- 이벤트 핸들러는 단추를 클릭하는 등의 작업을 수행할 때 `React`가 실행되는 기능입니다.
- 이벤트 핸들러가 컴포넌트 내에 존재해도 **렌더링 중**에는 실행되지 않습니다!
- 따라서 이벤트 핸들러는 순수할 필요가 없습니다.
  <br><br>

- 부수효과에 적합한 이벤트 핸들러를 찾을 수 없는 경우, 컴포넌트에서 `useEffect`를 호출하여 반환된 `JSX`에 연결할 수 있습니다.
- 이것은 `React`에게 **렌더링 후** 부수효과가 허용될 때 실행하도록 지시합니다.
- 하지만, 이 접근법이 당신의 마지막 수단이 되어야 합니다.
  <br><br>

- 가능하면 렌더링만으로 로직를 표현해 보십시오.

### 왜 React를 순수하게 유지해야 할까?

- 순수 함수는 약간의 습관과 훈련을 필요로 한다.
- 하지만 아래와 같은 놀라운 기능을 제공합니다.
  <br><br>

1. 예를 들어, 컴포넌트가 다른 환경에서 실행될 수 있습니다!
   - 동일한 입력에 대해 동일한 결과를 반환하기 때문에 1개 컴포넌트가 많은 사용자 요청을 처리할 수 있습니다.
2. 변경되지 않은 컴포넌트를 건너뛰어 성능을 향상시킬 수 있습니다.
   - 순수 함수는 항상 동일한 결과를 반환하므로 캐시하기에 안전합니다.
3. 심층 컴포넌트 트리를 렌더링 도중 데이터가 변경되면 `React`는 시간을 낭비하지 않고 렌더링을 **다시 시작** 할 수 있습니다.
   - 순수성은 언제든 중단해도 안전합니다.
     <br><br>

- 우리가 구현하고 있는 모든 새로운 리액트 기능은 순수성을 활용합니다.
- 컴포넌트를 순수하게 유지하면 `React` 패러다임의 힘을 발휘할 수 있습니다.

## 요약

- 컴포넌트는 순수해야 합니다.
  <br><br>

- 함수 자신의 기능에만 집중합니다. **렌더링 전**에 존재하는 객체 or 변수를 변경해서는 안 됩니다.
- 동일 입력, 동일 출력.
- 컴포넌트는 렌더링 순서에 의존하면 안 됩니다.
- 컴포넌트가 렌더링에 사용하는 입력을 변환하면 안 됩니다.
  - 여기에는 `props`, `state`, `context`가 포함됩니다.
  - UI를 업데이트하려면 객체를 변환하는 대신 상태를 `교체`하십시오.
- 반환하는 `JSX`에서 컴포넌트의 로직를 나타냅니다.
  - **변경**이 필요한 경우 일반적으로 **이벤트 핸들러**에서 변경할 수 있습니다.
    - 마지막 수단은 `useEffect` 입니다.
- 순수 함수 사용은 약간의 연습이 필요하지만, 그것은 리액트의 패러다임의 힘을 사용할 수 있게 합니다.
